# 深入理解计算机系统



## 第二部分 - 在系统上运行程序



### 第7章 - 链接


---



#### Some Question in Read

+ Q1：链接可发生在程序编译、加载以及执行阶段，哪些可重定位目标文件的链接发生在加载、执行阶段？这三种链接分别执行了哪些操作？为什么它们不在编译阶段执行链接（分别解决的什么问题）？

  > :question: **疑问**： 程序动态链接共享库，是如何做到不需要重新编译链接可执行目标文件的？

+ Q2：理解链接过程，得到了哪些代码编写时的注意事项？

+ Q3：目标文件可分为可重定位目标文件、可执行目标文件和共享目标文件，共享目标文件这类特殊的可重定位目标文件和普通的有什么区别？

+ Q4：可以通过STRIP命令去除可重定位目标文件中.symtab段的符号表，具体的操作是什么？这么做有什么意义？

+ Q5：`_init`函数是链接器自动生成的吗、代码开发人员可以修改吗、它的具体作用是什么？



#### 从源代码到程序运行

以C语言程序为例，它经过以下过程：预处理 -> 编译 -> 汇编 -> 链接 -> 加载 -> 执行。

加载过程从Shell输入可执行目标文件名开始，执行系统调用加载器`loader`将可执行目标文件的<mark>代码和数据</mark>复制到内存中，然后将控制转移给程序，程序开始执行。



#### 可重定位目标文件格式及各段作用

![image-20220403173048743](https://s2.loli.net/2022/04/03/jGJtkZlvMAsbXYm.png)

<center>可重定位目标文件格式</center>

+ ELF头：描述了可重定位目标文件的相关信息。

  ![image-20220404150745594](https://s2.loli.net/2022/04/04/UfJIRxEaVcoZFXi.png)

+ .text：已编译的机器代码。

+ .rodata：可重定位目标文件中只读的数据，包括只读变量（全局、静态）、字符串值、printf函数格式化字符串以及开关语句的跳转表等。

+ *.symtab*：一个符号表，存放着程序中定义和引用的函数和全局变量的信息。

  > :thinking:**思考**：为什么符号表中不存放静态局部变量的信息？局部变量的调用在程序运行期间，所以无需保存在symtab中供链接过程中使用。

+ *.rel.text*：.text段中机器指令引用符号位置的列表。当链接器将这个目标文件和其他文件合并时，需要更新这些信息，更新的信息包括<mark>引用的外部函数、全局变量</mark>，但是不包括调用的本地函数。
+ *.rel.data*：模块引用的或定义的全部全局变量的重定位信息。

+ *.debug*：一个调试符号表，包含程序中定义的变量名称和类型以及源文件名等信息。

+ *.line*：源码中行号和.text中机器指令之间的映射关系。

  > :notes:**提示**：仅在编译过程中使用编译选项`-g`会生成上述两个段，并且会使得文件占用存储空间大大增加。

+ *.strtab*：一个字符串表，包含.symtab、.debug段中符号名称等。



#### 符号表以及其中的符号

符号表中的符号可分为三种类型，如下：

1. 本文件中定义并能被其他模块使用的全局符号；
2. 在其他模块中定义并被当前文件引用的全局符号；
3. 本文件中定义的并且只能在当前文件中引用的局部符号。



符号表中的条目以如下结构进行组织，

```c
typedef struct {
    int name;	/* .strtab offset */
    char type: 4	/* the symble is function or data */
         binding: 4;	/* the symble is loacl or global */
    char reserved;	/* unused */
    short section;	/* section header index */
    long offset;	/* section offset or absolute address */
    long size;		/* object size in byte */
}
```



其中，可重定位目标文件中有三类特殊的分节，它们在可执行目标文件中是没有的，如下：

1. ABS：不该被重定位的符号；

2. UNDEF：在当前文件中引用在其他文件中定义的符号；

3. COMMON：未初始化的<mark>非静态</mark>全局变量。

   > :warning:**提醒**：未初始化的非静态全局变量属于弱定义符号，在链接过程中可能会被其他同名强定义全局符号遮盖，所以此时该类型的符号是未被分配空间的。*编码时，一定要避免该类型的符号出现，防止发生意料之外的情况出现*。

这三种分节中的符号是为了更好的被链接而生成的中间产物。

可以通过<font color = yellow>readelf -s xxx.o | grep "COMMON"</font>这种方式去检查当前文件中是否定义了未初始化的非静态全局变量。



#### 符号解析

*局部符号*的解析规则是<mark>每个模块的每个局部符号只允许有一个定义</mark>。

*静态局部变量*也有本地链接器符号，它通过<mark>编译器去保证它的唯一性</mark>，不需要经过符号解析。



*多重定义全局符号*的解析规则，如下：

+ 不允许多个重名的强符号，否则链接器报错；

+ 如果有一个强符号和多个弱符号同名，链接器选择使用强符号；

+ 如果有多个弱符号同名，随机选取一个使用。

  > 1. 强符号：函数、已初始化的全局变量。
  > 2. 弱符号：未初始化的全局变量。



以下列一组图说明*静态库文件*的符号解析过程，以`gcc -static -o proc main.o -L. -lvector`为例。

> 图中简化了许多内容，保留符号含义如下：
>
> 1. 符号描述
>    + DEF：当前模块定义的全局符号。
>    + UNDEF：当前模块未定义引用其他模块的全局符号。
> 2. 集合
>    + E：可重定位目标文件的集合。
>    + U：引用其他模块、还未定义的全局符号的集合。
>    + D：已定义全局符号的集合。

1. 开始时所有集合为空，链接器<mark>从左到右顺序</mark>解析各个可重定位目标文件；

![image-20220404213518510](https://s2.loli.net/2022/04/04/EV1gQd2NGCvXl4r.png)

2. 当前可重定位目标文件为中间目标文件，直接将当前文件更新到`E`中，同时更新`U`和`D`；

![image-20220404214730950](https://s2.loli.net/2022/04/04/If9aNdbL8X6jVF7.png)

3. 当前解析文件为静态库文件`vector.a`，当前集合`U`没有对成员文件`addVector.o`中定义符号的引用，抛弃它；集合`U`中引用符号`multVector`在成员文件`multVector.o`存在定义，将其加入集合`E`中，并将其中符号分别更新到集合`U`和`D`中。

![image-20220404220857341](https://s2.loli.net/2022/04/04/NegIp4sOSG92WdY.png)

> :question: **疑问**：静态库文件中各个成员文件中符号的相互引用是怎么处理的？

4. 同步骤3，解析结果如下；

![image-20220404221011779](https://s2.loli.net/2022/04/04/OGgJLKA2EN8yi95.png)

5. 所有文件解析完成，当前集合`U`为空，符号解析成功，由集合`E`中所有可重定位目标文件合并成可执行目标文件。

根据上述过程描述，链接器链接各可重定位目标文件时，应该<mark>先引用后定义</mark>，避免出现链接顺序导致的未定义问题。



#### 重定位

重定位的作用是将各个可重定位目标文件合并成可执行目标文件，并为每个符号分配运行时内存地址（虚拟地址空间）。该过程中可分为以下两个步骤：

1. 重定位节和重定位定义符号；
2. 更新引用符号地址。



符号重定位需要依赖汇编器生成的重定位条目表，重定位条目以以下结构进行组织，

```c
typedef struct {
    long offset;	/* offset of referance to relocate */
    long type 32:	/* relocation type */
    	 symbol 32:;	/* symble table index */
    long addend;	/* constant part of relocate experssion */
}Elf64_rela;
```

两种基本的重定位类型，

+ R_X86_64_PC32：使用32位PC相对地址重定位引用。通过<mark>引用符号运行时地址与执行当前引用该符号的机器指令PC值</mark>得到有效地址，常用于代码段`.text`的符号引用。
+ R_X86_64_32：使用绝对运行时地址重定位引用。通过<mark>引用符号运行时绝对地址和偏移量</mark>得到有效地址，常用于数据段`.data`的符号引用，<mark>因为数据段中内容不会被运行</mark>。



#### 可执行目标文件

![image-20220405152507806](C:\Users\Peter\AppData\Roaming\Typora\typora-user-images\image-20220405152507806.png)

<center>可执行目标文件格式</center>

可执行目标文件格式与可重定位目标文件大体相似，需要了解一下不同点，

+ `ELF`头中描述了程序的入口地址，即第一条要执行的机器指令；
+ `.init`：该段中定义了一个叫做`_init`的函数，用于被程序初始化代码调用；
+ 可执行目标文件中的段做了<mark>字节对齐</mark>的优化，使其更易于加载到虚拟内存空间中。



#### 可执行目标文件的加载过程

从在Shell命令行中输入程序名到main函数开始执行的过程叫做加载，该过程中发生的操作如下：

1. Shell命令行执行程序时，Shell父进程派生一个子进程，子进程通道调用`execve`函数来调用加载器`loader`；
2. `loader`删除子进程现有虚拟内存段并重新创建，重新创建后的栈、堆被初始化为0，通过将虚拟内存中代码段、数据段映射到可执行目标文件的对应段中，虚拟内存中代码段、数据段被初始化为可执行目标文件中的内容；
3. 然后，加载器跳转到程序的入口点`_start`函数，`_start`调用系统启动函数`_libc_start_main`，由它调用程序的`main`函数。

上述过程很简略，没有描述*`_init`段中函数是怎么生效的、动态库文件的加载时链接是怎么样的*。



不完全链接的可执行目标文件加载时，检测到当前存在`.interp`段，该段中包含动态链接器`dynamic linker`的路径名，*加载器会加载和链接动态链接器*，动态链接器完成其他共享库的加载和链接，通过以下两个步骤实现：

1. 重定位共享目标的代码和数据到某个内存段；
2. 更新可执行目标文件中对共享目标符号的引用。



<mark>通过共享库，无限多个进程可以共享一个共享模块的代码段，但是每个进程仍会有它自己的读写数据块。</mark>



#### 位置无关代码

当前共享库都实现成位置无关代码（Position Independent Code），通过编译共享库时加入编译选项`-fpic`实现。

##### PIC变量引用

共享库的运行时绝对位置在程序运行前是无法知道的，这带来两个问题：

+ 引用共享库全局变量符号的机器指令（在`.text`段）怎么在*静态链接*时更新引用地址？
+ 怎么保证更新的引用地址与最终的共享库运行时地址无关？

根据同一目标文件中*数据段与代码段的地址距离总是保持不变*，<mark>在数据段开始的地方创建一个叫做GOT（Global Offset Table）的表，用于存放当前目标文件引用共享库全局变量符号条目</mark>。如此，上面两个问题就得以解决：

+ 引用与GOT条目间距离是运行时的常量，可以通过PC32相对寻址重定位引用；
+ 动态加载共享库时，共享库可以加载在任何位置，只需重定位数据段中的GOT条目即可。

##### PIC函数引用

类似的，引用共享库的全局函数也可以通过重定位条目实现成位置无关代码，但是这样做存在一个问题：

+ 共享库中一般存在成百上千各外部接口，如果都在加载时重定位而实际被其他模块引用的接口又是少数，这样存在资源的极大浪费。

为解决该问题，引入了两个新的技术：

+ *延时绑定*`lazy banding`：引用共享库函数直到第一次调用才实际重定位该引用；
+ *过程链接表PLT*`procedure linkage table`：在<mark>代码段</mark>中创建`PLT`，每个函数引用都在`PLT`中有对应的条目，每个条目中记录了延时绑定函数所需执行的操作。延迟绑定需要借助`dynamic linkage`，所以在`PLT`中包含特殊条目`PLT[0]`存放动态链接器的入口。

#### 库打桩技术

*库打桩*，它允许你截获对共享库函数的调用，取而代之执行自己的代码。

通过库打桩技术，可以追踪对某个特殊函数的调用次数，验证和追踪它的输入输出值，甚至把它替换成一个完全不同的实现。

它的基本思想是，给需要打桩的目标函数创建一个<mark>包装函数</mark>，它的*原型*和目标函数完全一样。使用某种特殊的打桩机制，就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执行自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。打桩机制有以下几种：

+ 编译时打桩；
+ 链接时打桩；
+ 运行时打桩。

#### 处理目标文件的工具

+ `nm`：列出一个目标文件中符号表中定义的符号；
+ `readelf`：显示一个目标文件完整结构，包括目标文件头中的编码信息；
+ `objdump`：通常用于反汇编`.text`节中的二进制指令；
+ `ldd`：列出可执行目标文件在运行时所需的共享库。



#### Answer of  Those Question

+ A1

1. *中间目标文件*`.o`和*静态库文件*`.a`的链接发生在编译阶段；*动态库*`.so`的链接发生在加载或执行阶段。

2. 发生在不同阶段的链接，它们执行的操作也不同，如下：

   发生在***编译阶段***的链接叫做静态链接，该过程主要执行了两个操作：

   + 符号解析。它的操作对象是<mark>函数、全局变量以及静态变量</mark>，如果每个符号引用都***正好***和一处定义一一对应则符号解析成功；否则链接器提示链接错误；

     > :warning: **提醒：**局部变量在程序运行期间申请和使用，程序编译过程并没有它的参与。

   + 重定位。它的操作对象仍是上述符号，该过程将不同可重定位目标文件的相同段进行合并，使得每个<mark>符号定义</mark>都与虚拟地址空间中的唯一地址关联，然后更新这些符号的引用地址，该操作将不同的可重定位目标文件合并成适合加载到内存中的可执行目标文件。

   动态链接主要做的事情是重定位。

3. 动态链接解决了一些静态链接时存在的问题：

   + 加载时链接：如果有很多个程序依赖了同一个库文件，那么这些程序生成的可执行目标文件中都会包含库文件的成员文件，<mark>这对存储空间和内存空间都是浪费</mark>。通过加载时链接，在内存空间中只加载一次共享目标，所有程序共享该目标的代码和数据；
   + 程序运行时链接：不管是静态链接还是加载时链接库，都会在编译期间使用到库文件的信息，<mark>当库文件更新时，就需要重新生成执行目标文件</mark>。通过在程序运行期间动态加载共享库，动态符号解析和重定位，可以解除该限制。

+ A2
  - 通过变量修饰符`static`隐藏只在当前源文件中使用的变量或函数，使其对其他文件不可见；
  - 变量定义一定要进行初始化，防止链接过程中链接器做的一些兼容处理而导致意外发生；
  - 编写Makefile时，链接器命令行参数中加入`-fno-common`去避免多重定义符号，或者使用命令行参数`-Werror`使得所有的警告都输出错误；
  - 编写Makefile时，库文件放在命令行的最后，库文件间存在依赖关系的应先引用后定义原则，系统工程中可以有以下依赖顺序`-l(上层逻辑库) -l(中间封装库) -l(基础lib库) -l(系统调用库)`。



### 第8章 - 异常控制流



---



#### Some Question in Read

+ Q1：异常控制流描述了什么？了解它有什么作用？它的内容有哪些？
+ Q2：<mark>异常号</mark>和<mark>信号</mark>有什么区别和联系，例如发生*除0错误*时，会触发*SIGFPE*信号？

#### 异常

<mark>异常</mark>就是控制流的突变，用来响应处理器状态中的某些变化，处理器状态的变化也可以被称为<mark>事件</mark>。

任何情况下，当处理器检测到事件时，他就会通过*异常表*进行一个间接过程调用，到一个专门设计用来处理这类事件的*操作系统子程序（异常处理程序）*，当异常处理程序执行完成后，根据引起异常的事件类型，后续操作可能情况如下：

+ 再次执行引起异常的指令；
+ 执行没有异常发生时的下一条指令；
+ 终止引起异常的程序。



系统中可能的每种类型的异常都分配了一个唯一的非负整数的<mark>异常号</mark>。

在计算机启动时，操作系统会分配和初始化异常表，*以异常号为索引，每个表项都包含对应异常的异常处理函数地址*，异常表的起始地址放在*异常表基址寄存器*中。

异常类似于过程调用，重要的不同之处在于<u>异常处理函数运行在内核模式下</u>。



#### 异常类别

| 类别 | 原因              |           同步/异步           | 返回行为           |
| :--: | :---------------- | :---------------------------: | :----------------- |
| 中断 | 来自I/O设备的信号 | <font color = red>异步</font> | 总是返回下一条指令 |
| 陷阱 | 有意的异常        |             同步              | 总是返回下一条指令 |
| 故障 | 潜在可恢复的错误  |             同步              | 可能返回当前指令   |
| 终止 | 不可恢复的错误    |             同步              | 不会返回           |

1. 中断

   I/O设备通过*向处理器芯片上的一个引脚发信号*，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

2. 陷阱和系统调用

   陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是<mark>在用户程序和内核之间提供一个像过程调用的接口，叫做系统调用</mark>。例如，应用程序调用`read`、`fork`以及`execve`等时，其实就执行了*syscall*指令，该指令会触发一个陷阱。

3. 故障

   故障是由错误情况引起的，它可能可以由故障处理程序修正。如果故障修复，就将控制返回到引起故障的指令，从而重新执行它；否则，终止引起故障的程序。典型的故障是<mark>缺页异常</mark>，除此之外<mark>除0错误</mark>、<mark>一般保护故障（段错误）</mark>都属于故障。

4. 终止

   不可恢复的致命错误引起的结果，通常是一些*硬件错误*。



#### 进程

异常是允许操作系统内核提供进程概念的基本构造块。

进程给应用程序提供的两个关键抽象：

+ 一个独立的逻辑控制流，它提供一个假象，好像<mark>应用程序独占的使用处理器</mark>。
+ 一个私有的地址空间，它提供一个假象，好像<mark>应用程序独占的使用内存系统</mark>。



##### 逻辑控制流

PC（程序计数器）值的序列叫做逻辑控制流。

![image-20220417150508378](C:\Users\Peter\AppData\Roaming\Typora\typora-user-images\image-20220417150508378.png)

<u>每个*CPU*时间片内，仅有一个进程的逻辑控制流在执行</u>。各进程轮流使用*CPU*时间片，由于*CPU*的执行速度非常快，使得看来应用程序独立的使用处理器。



一个逻辑流的执行在时间上与另一个流重叠，称为<mark>并发流</mark>。

> **重叠**：流X在流Y开始之后、结束之前开始，也就是说流X、Y执行时在时间上有重叠。

并发流的思想与处理器的核心数、计算机数无关，只要在时间上有重叠就是并发的。<mark>并行流</mark>是并发流的一个真子集，它是两个流并发的运行在不同的处理器核或计算器上。



##### 私有空间地址

进程虚拟地址空间内核部分包含内核在当前进程执行时使用的代码、数据、栈以及堆等。



##### 用户模式和内核模式

*进程从用户模式变为内核模式的<font color = red>唯一办法</font>是通过中断、故障或者陷入系统调用等异常*。

当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式切换到内核模式；异常返回到应用程序代码时，模式切换回来。

*Linux*通过<mark>*/proc*文件系统</mark>，向用户模式进程提供一种可以访问内核数据结构内容的方法。



##### 上下文切换

操作系统内核使用称为<u>上下文切换</u>的更高层级形式的异常控制流来实现多任务。



内核为每个进程维持一个上下文，<mark>上下文</mark>就是内核重新启动进程所需的状态，它由一些对象的值组成，包括：

+ 通用目的寄存器
+ 浮点寄存器
+ 程序计数器
+ 用户栈
+ 状态寄存器
+ 内核栈
+ 各种内核数据结构，比如描述地址空间的页表、描述当前进程信息的进程表以及进程已打开文件的信息的文件表



内核调度了另一个进程运行后，就会强占当前进程，并使用<mark>上下文切换的机制</mark>将控制转移到调度进程：

1. 保存当前进程的上下文；
2. 恢复某个先前被强占进程的被保存的上下文；
3. 将控制转移到新调度的进程。



*当内核代表用户执行异常时，可能会发生上下文的切换*。比如系统调用因为等待某个时间发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。

![image-20220417162136929](C:\Users\Peter\AppData\Roaming\Typora\typora-user-images\image-20220417162136929.png)



#### 进程控制

> 描述了操作进程的系统调用的C语言程序调用接口。



+ 获取进程ID

  ```c
  pid_t getpid(void);		//< 获取当前进程ID，其中pid为int类型
  pid_t getppid(void);	//< 获取父进程ID
  ```



+ 创建和终止进程

  进程总处于三种状态：

  1. 运行。正在*CPU*上执行或等待*CPU*执行且最终会被内核调度；
  2. 停止。进程的执行被挂起且不会被调度，直到收到SIGCONT信号才再次运行；
  3. 终止。进程永远的停止了。原因有三种可能：
     - 收到默认行为为终止操作的信号；
     - 从主程序退出；
     - 调用*exit()*函数。

  ```c
  void exit(int status);		//< 终止进程，退出状态码为status
  ```

  父进程通过系统调用*fork()*创建新的运行的子进程。

  子进程得到父进程<font color = red>用户级虚拟地址空间</font>相同但独立的副本，还包括任何打开的文件描述符的副本。

  ```c
  pid_t fork(void);		//< 子进程返回0；父进程成功返回子进程ID，失败返回-1
  ```

  返回值用于<font color = red>*供调用者判断当前实在父进程还是子进程中执行*</font>。

  ```c
  int main(void)
  {
      int x = 1;
      pid_t child = 0;
      
      child = fork();
      if (0 == child)		// 判断当前是在父进程中执行还是子进程中执行
      {
          printf("Child: [%d].\n", ++x);
          exit(0);
      }
      printf("Parent: [%d].\n", --x);
      
      return 0;
  }
  
  执行结果如下：
  Parent: 0.
  Child: 0.
  ```



+ 回收子进程

  <font color = red>当一个进程终止时，系统并不会立即把它从系统中清除</font>，而是保持已终止的状态直到被父进程回收。一个终止了还未被回收的进程称为僵尸进程。

  僵尸进程被回收的方法有以下：

  + 在父进程中显示调用*waitpid*或*wait*回收子进程；
  + 在*signal()*系统调用中注册SIGCHLD信号的回调函数，回调函数中调用*waitpid*或*wait*回收子进程；
  + 杀死父进程，由*init*进程成为子进程的养父，回收子进程。



+ 让进程休眠

  ```c
  unsigned int sleep(unsigned int secs);		//< 将一个进程挂起指定的一段时间，返回值为还要休眠的秒数
  ```



+ 加载并运行程序

  在<font color = red>当前进程的上下文中</font>加载并运行一个新程序：

  ```c
  int execve(const char *filename, const char *argv[], const char *envp[]);//< 成功不返回，错误返回-1
  ```

  程序是一堆代码和数据，进程是执行中程序的一个具体的示例，程序总是运行在一个进程的上下文中。

  > :happy:**不怎么恰当的比喻**：<font color = red>程序和进程</font>的关系就犹如<font color = red>歌词和歌曲</font>，歌词只是一堆文字，加上编曲才可以变成美妙的歌声；而*fork*和*execve*就如生孩子和夺舍。



#### Answer of Those Question

+ A1

1. *控制流*是从第n条指令到第n+1条指令的CPU控制转移的过程。一般情况下，第n条指令和第n+1条指令的在内存中的地址是相邻的，这种控制转移过程就是平滑的。*当系统状态发生突变时，系统为了处理这种突变，控制转移会发生跳转，该过程就是<mark>异常控制流</mark>*`exceptional control flow`；
2. 帮助理解计算机系统中的一些重要概念，例如*I/O*、*进程*以及*虚拟内存*；除此之外，它也可以帮助应用程序如何与操作系统交互；
3. 计算机系统中所有层次上的各种形式的*ECF*。

+ A2

### 9 虚拟内存

---

虚拟内存提供了三个重要的能力，
+ 将<mark>主存</mark>看做是磁盘上地址空间的高速缓存，主存只保留活动区域；
+ 为每个进程提供了一致的地址空间，从而简化了内存管理；
+ 保护了每个进程的地址空间不被其他进程破坏。